{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Shasta User Guides \u00b6 This site contains user guides, tutorials and other information for users of the Shasta assembler. Shasta is a denovo assembler for Nanopore reads. The Shasta man pages and algorithmic overview can be found in the Shasta documentation . Contributing \u00b6 Contributions and ideas are welcome! Please don't hesitate to open an issue or send a pull request. To contribute to these documents, you should head over to the shasta-docs github repo . To contribute to Shasta (the software), head over to the shasta repo . This project is governed under the Contributor Covenant code of conduct. Getting help \u00b6 Don't hesitate to reach out to us on the Github issues, or join and reach out on the CZI Science Slack site . Security \u00b6 Please note: If you believe you have found a security issue, please responsibly disclose by contacting us at security@chanzuckerberg.com. License \u00b6 MIT \u00a9 2022 Chan Zuckerberg Initiative Foundation","title":"Home"},{"location":"#welcome-to-the-shasta-user-guides","text":"This site contains user guides, tutorials and other information for users of the Shasta assembler. Shasta is a denovo assembler for Nanopore reads. The Shasta man pages and algorithmic overview can be found in the Shasta documentation .","title":"Welcome to the Shasta User Guides"},{"location":"#contributing","text":"Contributions and ideas are welcome! Please don't hesitate to open an issue or send a pull request. To contribute to these documents, you should head over to the shasta-docs github repo . To contribute to Shasta (the software), head over to the shasta repo . This project is governed under the Contributor Covenant code of conduct.","title":"Contributing"},{"location":"#getting-help","text":"Don't hesitate to reach out to us on the Github issues, or join and reach out on the CZI Science Slack site .","title":"Getting help"},{"location":"#security","text":"Please note: If you believe you have found a security issue, please responsibly disclose by contacting us at security@chanzuckerberg.com.","title":"Security"},{"location":"#license","text":"MIT \u00a9 2022 Chan Zuckerberg Initiative Foundation","title":"License"},{"location":"about/","text":"E cervus vix neque loquendi se femina hello! \u00b6 Agitur et annis praebebat \u00b6 Lorem markdownum stringitur esse coniunx adsueta miseranda nitentem si tanta aestus, rogat. Ecce roseum notamque vos luco mihi fateamur vibrata ne dederat, et vultus moriens forsitan. Senectae disiecta, in humus in sua, sine, mutabile intacta mendacis tacitos iussus. Aut vestis domus dictis, mihi et nobis iniecique paribus non vel deus Epiros sceptri . Relinque territa consederat res tempora ille formam Fateri Fortunae quis Ergo limum praesentem fallere tenuisset levat cecidisse Alimentaque suisque maxima esse promissas caput Vitamque silvas equorum Est ille incomitata Ipsa ab ingenti canis panda \u00b6 Abdita aerii! Cura et pater quem caelestibus Laertius audito. Sunt Ceres ! Rector iam liceat, Iovis violentior misit quo sacras aliquid: auctaque, idem. Usa pectora, Cerealia cura, labens. Markdown Demos \u00b6 Simple table \u00b6 First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell More information . Code blocks \u00b6 A fenced code block: Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. print('hi there') A indented block: this is a test using more indentation! Images \u00b6 Credit: U.S. National Library of Medicine","title":"About"},{"location":"about/#e-cervus-vix-neque-loquendi-se-femina-hello","text":"","title":"E cervus vix neque loquendi se femina hello!"},{"location":"about/#agitur-et-annis-praebebat","text":"Lorem markdownum stringitur esse coniunx adsueta miseranda nitentem si tanta aestus, rogat. Ecce roseum notamque vos luco mihi fateamur vibrata ne dederat, et vultus moriens forsitan. Senectae disiecta, in humus in sua, sine, mutabile intacta mendacis tacitos iussus. Aut vestis domus dictis, mihi et nobis iniecique paribus non vel deus Epiros sceptri . Relinque territa consederat res tempora ille formam Fateri Fortunae quis Ergo limum praesentem fallere tenuisset levat cecidisse Alimentaque suisque maxima esse promissas caput Vitamque silvas equorum Est ille incomitata","title":"Agitur et annis praebebat"},{"location":"about/#ipsa-ab-ingenti-canis-panda","text":"Abdita aerii! Cura et pater quem caelestibus Laertius audito. Sunt Ceres ! Rector iam liceat, Iovis violentior misit quo sacras aliquid: auctaque, idem. Usa pectora, Cerealia cura, labens.","title":"Ipsa ab ingenti canis panda"},{"location":"about/#markdown-demos","text":"","title":"Markdown Demos"},{"location":"about/#simple-table","text":"First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell More information .","title":"Simple table"},{"location":"about/#code-blocks","text":"A fenced code block: Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. print('hi there') A indented block: this is a test using more indentation!","title":"Code blocks"},{"location":"about/#images","text":"Credit: U.S. National Library of Medicine","title":"Images"},{"location":"faq/","text":"FAQ \u00b6 Do I need to preprocess my reads? \u00b6 No. Shasta accepts unprocessed reads as input in .fasta or .fastq format. Compressed files are not supported, so make sure you decompress them before running Shasta. Any reads shorter than the Reads.minReadLength (default 10000) containing bases with repeat counts >255 are automatically discarded. You can adjust the minimum read length in the assembly using the Reads.minReadLength. Does it matter what version of Guppy I used to basecall my reads? \u00b6 Yes. For optimal results, please basecall your ONT reads with the latest version of Guppy 5 or 6 using the super accuracy mode. If your reads are Guppy 4 or earlier, it is worth re-basecalling them before running an assembly. Can I run Shasta using Docker? \u00b6 Yes! Documentation can be found in the Shasta man pages What is the minimum read coverage required for standard ONT reads? \u00b6 For standard ONT reads, Shasta performs well with at least 30x coverage of reads \u226510Kb. Optimal coverage is 50-80x of reads \u226510Kb. You can adjust the coverage by specifying the desired value for total coverage, in bases with the command --Reads.desiredCoverage. For example, to adjust the desired coverage for a 1 Gb genome to 60x, use --Reads.desiredCoverage 60G. What is the minimum read coverage required for ultra-long ONT reads? \u00b6 The optimal coverage for ultra-long (UL) reads is 60-80x of reads N50 \u2265 50Kb. How much memory do I need for my genome? \u00b6 Shasta works on a single large machine and operates in memory. Memory requirements are roughly proportional to genome size and coverage and are around 4-6 bytes per input base. For a human-size genome (~3 Gb) at 60x, this works out to ~1 TB of memory. Machines with 1-24 TB of memory are available at reasonable prices on cloud computing platforms (e.g., AWS EC2 instances). For all assemblies requiring up to 1 TB, you should use ARM x2gd instance types. These instances are available at ~$3/hour as on-demand instances. They complete a human assembly at coverage 60x in ~5 hours, at the cost of ~$15 per assembly. See our documentation for more detailed information on memory requirements, memory modes and running Shasta with less than optimal memory (i.e,. for very small genomes). How do I choose a config? \u00b6 As a starting point, please use the latest assembly configuration corresponding to the length of reads you have and the type of assembly you want to run. For example, if you have standard ONT reads and want to run a haploid assembly, please use Nanopore-May2022. If you're going to run a haploid assembly with ultra-long ONT reads, please use Nanopore-UL-May2022. For more detail please see the documentation . Are diploid phased genome assemblies supported? \u00b6 Yes. However, this algorithm is being actively developed and improved. Please run phased assemblies using the appropriate config (i.e., Nanopore-Phased-May2022 or Nanopore-UL-Phased-May2022). For more information, see the docs. My assembly size/contiguity is not what I expected; what parameters can I tweak? \u00b6 If there is a reference for your species or you have an estimate of the genome size from flow cytometry or karyotyping, then the size of your Shasta assembly should be close to the estimated size. Although, we usually find that Shasta assemblies are slightly smaller than the estimated size. You can try tweaking the read length cutoff --Reads.minReadLength. The default is 10000 for standard ONT reads. If you have low coverage (i.e., less than 60x), you could lower the --Reads.minReadLength (in 2,500-5,000 intervals) increases the amount of coverage used in the assembly and potentially increases the assembly size. If you have reads with 60-80x coverage, you can try increasing the --Reads.minReadLength (in 2,500-5,000 intervals) to remove smaller reads from the assembly and potentially increase the contiguity. If the above recipe does produce the desired result we recommend you, 1) increase the number of MinHash iterations, for example to 100, 2) set the read graph creation method to 0 (no adaptivity in selecting alignment criteria), 3. experiment with alignment criteria, starting with the values chosen in the out of the box assembly (they are in the assembly log). Generally one needs to increase both minAlignedMarkerCount and minAlignedFraction. What polisher do you recommend? \u00b6 For human genomes, we recommend Pepper-Margin-DeepVariant . For non-humans, we have had good results using one round of the Flye polisher , but results may vary.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#do-i-need-to-preprocess-my-reads","text":"No. Shasta accepts unprocessed reads as input in .fasta or .fastq format. Compressed files are not supported, so make sure you decompress them before running Shasta. Any reads shorter than the Reads.minReadLength (default 10000) containing bases with repeat counts >255 are automatically discarded. You can adjust the minimum read length in the assembly using the Reads.minReadLength.","title":"Do I need to preprocess my reads?"},{"location":"faq/#does-it-matter-what-version-of-guppy-i-used-to-basecall-my-reads","text":"Yes. For optimal results, please basecall your ONT reads with the latest version of Guppy 5 or 6 using the super accuracy mode. If your reads are Guppy 4 or earlier, it is worth re-basecalling them before running an assembly.","title":"Does it matter what version of Guppy I used to basecall my reads?"},{"location":"faq/#can-i-run-shasta-using-docker","text":"Yes! Documentation can be found in the Shasta man pages","title":"Can I run Shasta using Docker?"},{"location":"faq/#what-is-the-minimum-read-coverage-required-for-standard-ont-reads","text":"For standard ONT reads, Shasta performs well with at least 30x coverage of reads \u226510Kb. Optimal coverage is 50-80x of reads \u226510Kb. You can adjust the coverage by specifying the desired value for total coverage, in bases with the command --Reads.desiredCoverage. For example, to adjust the desired coverage for a 1 Gb genome to 60x, use --Reads.desiredCoverage 60G.","title":"What is the minimum read coverage required for standard ONT reads?"},{"location":"faq/#what-is-the-minimum-read-coverage-required-for-ultra-long-ont-reads","text":"The optimal coverage for ultra-long (UL) reads is 60-80x of reads N50 \u2265 50Kb.","title":"What is the minimum read coverage required for ultra-long ONT reads?"},{"location":"faq/#how-much-memory-do-i-need-for-my-genome","text":"Shasta works on a single large machine and operates in memory. Memory requirements are roughly proportional to genome size and coverage and are around 4-6 bytes per input base. For a human-size genome (~3 Gb) at 60x, this works out to ~1 TB of memory. Machines with 1-24 TB of memory are available at reasonable prices on cloud computing platforms (e.g., AWS EC2 instances). For all assemblies requiring up to 1 TB, you should use ARM x2gd instance types. These instances are available at ~$3/hour as on-demand instances. They complete a human assembly at coverage 60x in ~5 hours, at the cost of ~$15 per assembly. See our documentation for more detailed information on memory requirements, memory modes and running Shasta with less than optimal memory (i.e,. for very small genomes).","title":"How much memory do I need for my genome?"},{"location":"faq/#how-do-i-choose-a-config","text":"As a starting point, please use the latest assembly configuration corresponding to the length of reads you have and the type of assembly you want to run. For example, if you have standard ONT reads and want to run a haploid assembly, please use Nanopore-May2022. If you're going to run a haploid assembly with ultra-long ONT reads, please use Nanopore-UL-May2022. For more detail please see the documentation .","title":"How do I choose a config?"},{"location":"faq/#are-diploid-phased-genome-assemblies-supported","text":"Yes. However, this algorithm is being actively developed and improved. Please run phased assemblies using the appropriate config (i.e., Nanopore-Phased-May2022 or Nanopore-UL-Phased-May2022). For more information, see the docs.","title":"Are diploid phased genome assemblies supported?"},{"location":"faq/#my-assembly-sizecontiguity-is-not-what-i-expected-what-parameters-can-i-tweak","text":"If there is a reference for your species or you have an estimate of the genome size from flow cytometry or karyotyping, then the size of your Shasta assembly should be close to the estimated size. Although, we usually find that Shasta assemblies are slightly smaller than the estimated size. You can try tweaking the read length cutoff --Reads.minReadLength. The default is 10000 for standard ONT reads. If you have low coverage (i.e., less than 60x), you could lower the --Reads.minReadLength (in 2,500-5,000 intervals) increases the amount of coverage used in the assembly and potentially increases the assembly size. If you have reads with 60-80x coverage, you can try increasing the --Reads.minReadLength (in 2,500-5,000 intervals) to remove smaller reads from the assembly and potentially increase the contiguity. If the above recipe does produce the desired result we recommend you, 1) increase the number of MinHash iterations, for example to 100, 2) set the read graph creation method to 0 (no adaptivity in selecting alignment criteria), 3. experiment with alignment criteria, starting with the values chosen in the out of the box assembly (they are in the assembly log). Generally one needs to increase both minAlignedMarkerCount and minAlignedFraction.","title":"My assembly size/contiguity is not what I expected; what parameters can I tweak?"},{"location":"faq/#what-polisher-do-you-recommend","text":"For human genomes, we recommend Pepper-Margin-DeepVariant . For non-humans, we have had good results using one round of the Flye polisher , but results may vary.","title":"What polisher do you recommend?"},{"location":"public_assemblies/","text":"Public Assemblies \u00b6 The following assemblies are vailable Assembly Description T2T CHM13 rel8 ONT UL Shasta 0.9.0 assembly of CHM13, starting with 120X ultra-long nanopore reads. and another one and another description","title":"Public Assemblies"},{"location":"public_assemblies/#public-assemblies","text":"The following assemblies are vailable Assembly Description T2T CHM13 rel8 ONT UL Shasta 0.9.0 assembly of CHM13, starting with 120X ultra-long nanopore reads. and another one and another description","title":"Public Assemblies"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/","text":"Shasta assembly of T2T CHM13 rel8 Oxford Nanopore ultra-long reads \u00b6 Motivation \u00b6 Advances in Oxford Nanopore Technologies (ONT) sequencing, base-calling, and updates to Shasta are outpacing the publishing cycle. We aim to update users on state-of-the-art using the latest and greatest ONT data assembled with Shasta. This release encompassed our latest assembly of CHM13, the AssemblySummary.html, and Assembly.gfa, along with an evaluation. We assembled 120x ultra-long nanopore reads of CHM13 using Shasta 0.9.0 with the iterative assembly mode to produce a haploid de novo genome assembly. Methods \u00b6 We downloaded publicly available reads created by the \"Telomere-to-Telomere\" (T2T) Consortium to assemble CHM13. For a description of sequencing methods by the T2T Consortium, please see https://github.com/marbl/CHM13#oxford-nanopore-data. Release 8 of the data was re-called with Guppy v5.0.7 in super accuracy mode. T2T CHM13 rel8 reads \u00b6 https://s3-us-west-2.amazonaws.com/human-pangenomics/T2T/CHM13/nanopore/rel8-guppy-5.0.7/reads.fastq.gz We assembled the reads using Shasta 0.9.0 (Shafin et al., 2020) in the iterative assembly mode by calling the Nanopore-Sep2020 configuration, plus additional command line options listed below. We ran the assembly on McCloud , a service that runs Shasta in the cloud. Shasta command line options \u00b6 --Reads.minReadLength 50000 --Kmers.k 10 --MinHash.minHashIterationCount 100 --Align.minAlignedFraction 0.35 --Align.minAlignedMarkerCount 600 --Align.maxSkip 50 --Align.maxDrift 30 --Align.maxTrim 30 --ReadGraph.creationMethod 0 --ReadGraph.maxAlignmentCount 12 --ReadGraph.crossStrandMaxDistance 0 --MarkerGraph.refineThreshold 0 --MarkerGraph.minCoveragePerStrand 3 --MarkerGraph.simplifyMaxLength 10,100,1000,10000 --Assembly.iterative --Assembly.pruneLength 10000 --Assembly.consensusCaller Bayesian:guppy-5.0.7-a Files \u00b6 Genome assembly file Assembly of CHM13 in FASTA format (one strand only). shasta_0.9.0_chm13_assembly.fasta Genome assembly summary file Assembly summary information in html format. AssemblySummary.html Graphical fragment assembly file Assembly in GFA format (one strand only). Assembly.gfa Assembly evaluation Results of our evaluation of the assembly using QUAST and asmgene presented in tables and figures. shasta_0.9.0_chm13_evaluation.pdf Evaluation \u00b6 Table 1. Summary of the size, contiguity, correctness, and completeness statistics for CHM13 Shasta assembly. We evaluated the assembly with QUAST 5.1.0rcr1 (Gurevich et al., 2013) using T2T-CHM13 v1.1 as the reference (Nurk et al. , 2022). Assembly size (Gb) N50 (Mb) NG50 (Mb) NGA50 (Mb) mismatches per 100 kbp indels per 100 kbp Genome fraction 2.96 91.98 91.98 87.79 16 42 96.84 Table 2. Assembly gene completeness metrics from a asmgene reference-based analysis (Li, 2018) using Ensembl transcripts mapped to the T2T-CHM13 v1.1 reference and the Shasta 0.9.0 assembly. This analysis is similar to BUSCO, but uses all the genes in the human genome. Metric Description genesToReference geneToAssembly Percent full_sgl Complete single-copy genes 34582 34480 99.71% full_dup Misassembled as multi-copy genes 0 4 0.01% frag Fragmented genes 0 4 0.01% part50+ Genes mapped over 50% of their length 0 28 0.08% part10+ Genes mapped over 10% of their length 0 2 0.01% part10- Genes mapped below 10% of their length or unmapped 0 64 0.19% dup_cnt Fraction of missing multi-copy genes 1172 1101 6.06% Figure 1. NGx plot showing contig lengths and their cumulative length in order of descending contig size for CHM13 reads assembled with Shasta 0.9.0 (blue line), CHM13 reads assembled with Shasta 0.1.0 (green; Shafin et al., 2020) and the chromosome arm lengths of theT2T- CHM13 v1.1 assembly (purple). The Shasta 0.9.0 assembly has three contigs that span nearly the length of whole chromosomes. Plotted using a custom script available at https://github.com/rlorigro/GFAse/blob/main/scripts/plot_ngx.py. Figure 2. Single-stranded GFA of CHM13 rel8 ONT reads assembled with Shasta 0.9.0. Contigs are colored and labeled according to their corresponding human chromosome number and arm (p=short,q=long). Plotted using Bandage (Wick et al. , 2015). Figure 3. Assembled contigs are plotted in blue and orange above chromosome ideograms of CHM13 T2Tv1.1 reference. Three chromosomes were assembled in essentially one contig (chr8, chr11, chrX), minus the telomeres, and with small gaps in centromeric higher-order repeats (HORs). Thirty chromosome arms are reconstructed in one contig, minus telomeres. However, gaps in the assembly remain in difficult to assembly regions. For example, the acrocentric arms of chr13 and chr15; pericentromeric regions in chr1, chr9 and chr16; and the centromeres of chr17, chr18, chr19, and chr22. The ideogram was plotted in R using the script: https://github.com/mrvollger/asm-to-reference-alignment/blob/main/workflow/scripts/ideogram.R References \u00b6 Gurevich,A. et al. (2013) QUAST: quality assessment tool for genome assemblies. Bioinformatics , 29 , 1072\u20131075. Li,H. (2018) Minimap2: pairwise alignment for nucleotide sequences. Bioinformatics , 34 , 3094\u20133100. Nurk,S. et al. (2022) The complete sequence of a human genome. Science , 376 , 44\u201353. Shafin,K. et al. (2020) Nanopore sequencing and the Shasta toolkit enable efficient de novo assembly of eleven human genomes. Nat. Biotechnol. , 38 , 1044\u20131053. Wick,R.R. et al. (2015) Bandage: interactive visualization of de novo genome assemblies. Bioinformatics , 31 , 3350\u20133352.","title":"Shasta assembly of T2T CHM13 rel8 Oxford Nanopore ultra-long reads"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#shasta-assembly-of-t2t-chm13-rel8-oxford-nanopore-ultra-long-reads","text":"","title":"Shasta assembly of T2T CHM13 rel8 Oxford Nanopore ultra-long reads"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#motivation","text":"Advances in Oxford Nanopore Technologies (ONT) sequencing, base-calling, and updates to Shasta are outpacing the publishing cycle. We aim to update users on state-of-the-art using the latest and greatest ONT data assembled with Shasta. This release encompassed our latest assembly of CHM13, the AssemblySummary.html, and Assembly.gfa, along with an evaluation. We assembled 120x ultra-long nanopore reads of CHM13 using Shasta 0.9.0 with the iterative assembly mode to produce a haploid de novo genome assembly.","title":"Motivation"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#methods","text":"We downloaded publicly available reads created by the \"Telomere-to-Telomere\" (T2T) Consortium to assemble CHM13. For a description of sequencing methods by the T2T Consortium, please see https://github.com/marbl/CHM13#oxford-nanopore-data. Release 8 of the data was re-called with Guppy v5.0.7 in super accuracy mode.","title":"Methods"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#t2t-chm13-rel8-reads","text":"https://s3-us-west-2.amazonaws.com/human-pangenomics/T2T/CHM13/nanopore/rel8-guppy-5.0.7/reads.fastq.gz We assembled the reads using Shasta 0.9.0 (Shafin et al., 2020) in the iterative assembly mode by calling the Nanopore-Sep2020 configuration, plus additional command line options listed below. We ran the assembly on McCloud , a service that runs Shasta in the cloud.","title":"T2T CHM13 rel8 reads"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#shasta-command-line-options","text":"--Reads.minReadLength 50000 --Kmers.k 10 --MinHash.minHashIterationCount 100 --Align.minAlignedFraction 0.35 --Align.minAlignedMarkerCount 600 --Align.maxSkip 50 --Align.maxDrift 30 --Align.maxTrim 30 --ReadGraph.creationMethod 0 --ReadGraph.maxAlignmentCount 12 --ReadGraph.crossStrandMaxDistance 0 --MarkerGraph.refineThreshold 0 --MarkerGraph.minCoveragePerStrand 3 --MarkerGraph.simplifyMaxLength 10,100,1000,10000 --Assembly.iterative --Assembly.pruneLength 10000 --Assembly.consensusCaller Bayesian:guppy-5.0.7-a","title":"Shasta command line options"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#files","text":"Genome assembly file Assembly of CHM13 in FASTA format (one strand only). shasta_0.9.0_chm13_assembly.fasta Genome assembly summary file Assembly summary information in html format. AssemblySummary.html Graphical fragment assembly file Assembly in GFA format (one strand only). Assembly.gfa Assembly evaluation Results of our evaluation of the assembly using QUAST and asmgene presented in tables and figures. shasta_0.9.0_chm13_evaluation.pdf","title":"Files"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#evaluation","text":"Table 1. Summary of the size, contiguity, correctness, and completeness statistics for CHM13 Shasta assembly. We evaluated the assembly with QUAST 5.1.0rcr1 (Gurevich et al., 2013) using T2T-CHM13 v1.1 as the reference (Nurk et al. , 2022). Assembly size (Gb) N50 (Mb) NG50 (Mb) NGA50 (Mb) mismatches per 100 kbp indels per 100 kbp Genome fraction 2.96 91.98 91.98 87.79 16 42 96.84 Table 2. Assembly gene completeness metrics from a asmgene reference-based analysis (Li, 2018) using Ensembl transcripts mapped to the T2T-CHM13 v1.1 reference and the Shasta 0.9.0 assembly. This analysis is similar to BUSCO, but uses all the genes in the human genome. Metric Description genesToReference geneToAssembly Percent full_sgl Complete single-copy genes 34582 34480 99.71% full_dup Misassembled as multi-copy genes 0 4 0.01% frag Fragmented genes 0 4 0.01% part50+ Genes mapped over 50% of their length 0 28 0.08% part10+ Genes mapped over 10% of their length 0 2 0.01% part10- Genes mapped below 10% of their length or unmapped 0 64 0.19% dup_cnt Fraction of missing multi-copy genes 1172 1101 6.06% Figure 1. NGx plot showing contig lengths and their cumulative length in order of descending contig size for CHM13 reads assembled with Shasta 0.9.0 (blue line), CHM13 reads assembled with Shasta 0.1.0 (green; Shafin et al., 2020) and the chromosome arm lengths of theT2T- CHM13 v1.1 assembly (purple). The Shasta 0.9.0 assembly has three contigs that span nearly the length of whole chromosomes. Plotted using a custom script available at https://github.com/rlorigro/GFAse/blob/main/scripts/plot_ngx.py. Figure 2. Single-stranded GFA of CHM13 rel8 ONT reads assembled with Shasta 0.9.0. Contigs are colored and labeled according to their corresponding human chromosome number and arm (p=short,q=long). Plotted using Bandage (Wick et al. , 2015). Figure 3. Assembled contigs are plotted in blue and orange above chromosome ideograms of CHM13 T2Tv1.1 reference. Three chromosomes were assembled in essentially one contig (chr8, chr11, chrX), minus the telomeres, and with small gaps in centromeric higher-order repeats (HORs). Thirty chromosome arms are reconstructed in one contig, minus telomeres. However, gaps in the assembly remain in difficult to assembly regions. For example, the acrocentric arms of chr13 and chr15; pericentromeric regions in chr1, chr9 and chr16; and the centromeres of chr17, chr18, chr19, and chr22. The ideogram was plotted in R using the script: https://github.com/mrvollger/asm-to-reference-alignment/blob/main/workflow/scripts/ideogram.R","title":"Evaluation"},{"location":"public_assemblies/T2T_CHM13_rel8_ONT_UL/#references","text":"Gurevich,A. et al. (2013) QUAST: quality assessment tool for genome assemblies. Bioinformatics , 29 , 1072\u20131075. Li,H. (2018) Minimap2: pairwise alignment for nucleotide sequences. Bioinformatics , 34 , 3094\u20133100. Nurk,S. et al. (2022) The complete sequence of a human genome. Science , 376 , 44\u201353. Shafin,K. et al. (2020) Nanopore sequencing and the Shasta toolkit enable efficient de novo assembly of eleven human genomes. Nat. Biotechnol. , 38 , 1044\u20131053. Wick,R.R. et al. (2015) Bandage: interactive visualization of de novo genome assemblies. Bioinformatics , 31 , 3350\u20133352.","title":"References"}]}